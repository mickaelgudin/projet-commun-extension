{
	"@Prop": {
        "prefix": "@Prop",
        "body": [ "@Prop(Number) readonly propA: number | undefined" ],
        "description": "complete @Prop attribute decorator"
    },
	"@PropSync": {
        "prefix": "@PropSync",
        "body": [ "@PropSync('name', { type: String }) syncedName!: string" ],
        "description": "complete @PropSync attribute decorator"
    },
	"@Model": {
        "prefix": "@Model",
        "body": [ "@Model('change', { type: Boolean }) readonly checked!: boolean" ],
        "description": "complete @Model attribute decorator"
    },
	"@ModelSync": {
        "prefix": "@ModelSync",
        "body": [ "@ModelSync('checked', 'change', { type: Boolean }) readonly checkedValue!: boolean" ],
        "description": "complete @ModelSync attribute decorator"
    },
	"@Watch": {
        "prefix": "@Watch",
        "body": [ "@Watch('${0:property}')" ],
        "description": "complete @Watch attribute decorator"
    },
	"@Provide": {
        "prefix": "@Provide",
        "body": [ "@Provide('bar') ${0:nameProperty} = 'bar'" ],
        "description": "complete @Provide attribute decorator"
    },
	"@Inject": {
        "prefix": "@Inject",
        "body": [ "@Inject('bar') readonly bar!: string" ],
        "description": "complete @Inject attribute decorator"
    },
	"@ProvideReactive": {
        "prefix": "@ProvideReactive",
        "body": [ "@ProvideReactive() one = '${0:value}'" ],
        "description": "complete @ProvideReactive attribute decorator"
    },
	"@InjectReactive": {
        "prefix": "@InjectReactive",
        "body": [ "@InjectReactive() {0:name}!: string" ],
        "description": "complete @InjectReactive attribute decorator"
    },
	"@Emit": {
        "prefix": "@Emit",
        "body": [ "@Emit()" ],
        "description": "complete @Emit attribute decorator"
    },
	"@Ref": {
        "prefix": "@Ref",
        "body": [ "@Ref() readonly ${1:anotherComponent}!: ${0:AnotherComponent}" ],
        "description": "complete @Ref attribute decorator"
    },
	"@VModel": {
        "prefix": "@VModel",
        "body": [ "@VModel({ type: String }) name!: string" ],
        "description": "complete @VModel attribute decorator"
    },
	"@Component": {
        "prefix": "@Component",
        "body": [ "@Component" ],
        "description": "complete @Component attribute decorator"
    },
	"Mixins": {
        "prefix": "Mixins",
        "body": [ "Mixins " ],
        "description": "complete Mixins attribute decorator"
    },
    "vue-class-component": {
        "prefix": "vue-class-component",
        "body": [ 
            "@Component ",
            "export default class LoginForm extends Vue {",
            "\t${0}",
            "}"
        ],
        "description": "complete basic vue-class-component"
    },
    "Meteor": {
        "prefix": "Meteor",
        "body": [ "Meteor " ],
        "description": "complete Meteor class"
    },
    "Meteor.startup()": {
        "prefix": "Meteor.startup()",
        "body": [ 
            "Meteor.startup(() => {",
            "\tnew Vue({",
            "\t\tel: '#app',",
            "\t\t...App,",
            "\t\t...router,",
            "\t})",
            "})"
        ],
        "description": "complete Meteor class"
    },
    "Meteor.methods": {
        "prefix": "Meteor.methods",
        "body": [ 
            "Meteor.methods({",
            "\tmethod(text) {",
            "\t\treturn 'meteor method : '+text;",
            "\t},",
            "}"
        ],
        "description": "complete Meteor class"
    },
    "Meteor.publish": {
        "prefix": "Meteor.publish",
        "body": [ 
            "Meteor.publish('tasks', function publishTasks() {",
            "\treturn TasksCollection.find({ userId: this.userId });",
            "});"
        ],
        "description": "complete Meteor class"
    },
    

    "VueRouter": {
        "prefix": "VueRouter",
        "body": [ 
            "new VueRouter({ ",
            "\troutes: [",
            "\t\t{path: '/', component: Home, name: '/'}",
            "\t],",
            "\tbase: '/Login'",
            "})"
        ],
        "description": "complete Meteor class"
    },

    "mocha.slow": {
        "prefix": "mocha.slow",
        "body": [ 
            "mocha.slow(500)"
        ],
        "description": "Sets slowness threshold value."
    },

    "mocha.addFile": {
        "prefix": "mocha.addFile",
        "body": [ 
            "mocha.addFile('path')"
        ],
        "description": "Adds file to be loaded for execution."
    },

    "mocha.allowUncaught": {
        "prefix": "mocha.allowUncaught",
        "body": [ 
            "mocha.allowUncaught(true)"
        ],
        "description": "Enables or disables uncaught errors to propagate."
    },

    "mocha.asyncOnly": {
        "prefix": "mocha.asyncOnly",
        "body": [ 
            "mocha.asyncOnly(true)"
        ],
        "description": "Forces all tests to either accept a done callback or return a promise."
    },

    "mocha.bail": {
        "prefix": "mocha.bail",
        "body": [ 
            "mocha.bail(true)"
        ],
        "description": "Enables or disables bailing on the first failure."
    },

    "mocha.checkLeaks": {
        "prefix": "mocha.checkLeaks",
        "body": [ 
            "mocha.checkLeaks(true)"
        ],
        "description": "Enables or disables checking for global variables leaked while running tests."
    },

    "mocha.color": {
        "prefix": "mocha.color",
        "body": [ 
            "mocha.color(true)"
        ],
        "description": "Enables or disables TTY color output by screen-oriented reporters."
    },

    "mocha.delay": {
        "prefix": "mocha.delay",
        "body": [ 
            "mocha.delay()"
        ],
        "description": "Delays root suite execution."
    },

    "mocha.diff": {
        "prefix": "mocha.diff",
        "body": [ 
            "mocha.diff(true)"
        ],
        "description": "Enables or disables reporter to include diff in test failure output."
    },

    "mocha.dispose": {
        "prefix": "mocha.dispose",
        "body": [ 
            "mocha.dispose()"
        ],
        "description": "Manually dispose this mocha instance. Mark this instance as disposed and unable to run more tests."
    },

    "mocha.enableGlobalSetup": {
        "prefix": "mocha.enableGlobalSetup",
        "body": [ 
            "mocha.enableGlobalSetup(true)"
        ],
        "description": "Toggle execution of any global setup fixture(s)"
    },

    "mocha.enableGlobalTeardown": {
        "prefix": "mocha.enableGlobalTeardown",
        "body": [ 
            "mocha.enableGlobalTeardown(true)"
        ],
        "description": "Toggle execution of any global teardown fixture(s)"
    },

    "mocha.fgrep": {
        "prefix": "mocha.fgrep",
        "body": [ 
            "mocha.fgrep('foo.')"
        ],
        "description": "Sets grep filter after escaping RegExp special characters."
    },

    "mocha.forbidOnly": {
        "prefix": "mocha.forbidOnly",
        "body": [ 
            "mocha.forbidOnly(true)"
        ],
        "description": "Causes tests marked only to fail the suite."
    },

    "mocha.forbidPending": {
        "prefix": "mocha.forbidPending",
        "body": [ 
            "mocha.forbidPending(true)"
        ],
        "description": "Causes pending tests and tests marked skip to fail the suite."
    },

    "mocha.fullTrace": {
        "prefix": "mocha.fullTrace",
        "body": [ 
            "mocha.fullTrace(true)"
        ],
        "description": "Displays full stack trace upon test failure."
    },

    "mocha.global": {
        "prefix": "mocha.global",
        "body": [ 
            "mocha.global(['jQuery', 'MyLib'])"
        ],
        "description": "Specifies whitelist of variable names to be expected in global scope."
    },

    "mocha.globalSetup": {
        "prefix": "mocha.globalSetup",
        "body": [ 
            "mocha.globalSetup(setupFns = [])"
        ],
        "description": "Configures one or more global setup fixtures. If given no parameters, unsets any previously-set fixtures.        "
    },

    "mocha.globalTeardown": {
        "prefix": "mocha.globalTeardown",
        "body": [ 
            "mocha.globalTeardown(teardownFns = [])"
        ],
        "description": "Configures one or more global teardown fixtures. If given no parameters, unsets any previously-set fixtures."
    },

    "mocha.grep": {
        "prefix": "mocha.grep",
        "body": [ 
            "mocha.grep(/match/i)"
        ],
        "description": "Sets grep filter used to select specific tests for execution."
    },

    "mocha.growl": {
        "prefix": "mocha.growl",
        "body": [ 
            "mocha.growl()"
        ],
        "description": "Enables desktop notification support if prerequisite software installed."
    },

    "mocha.hasGlobalSetupFixtures": {
        "prefix": "mocha.hasGlobalSetupFixtures",
        "body": [ 
            "mocha.hasGlobalSetupFixtures()"
        ],
        "description": "Returns true if one or more global setup fixtures have been supplied."
    },

    "mocha.hasGlobalTeardownFixtures": {
        "prefix": "mocha.hasGlobalTeardownFixtures",
        "body": [ 
            "mocha.hasGlobalTeardownFixtures()"
        ],
        "description": "Returns true if one or more global teardown fixtures have been supplied."
    },

    "mocha.inlineDiffs": {
        "prefix": "mocha.inlineDiffs",
        "body": [ 
            "mocha.inlineDiffs(true)"
        ],
        "description": "Enables or disables reporter to use inline diffs (rather than +/-) in test failure output."
    },

    "mocha.invert": {
        "prefix": "mocha.invert",
        "body": [ 
            "mocha.invert()"
        ],
        "description": "Inverts grep matches."
    },

    "mocha.lazyLoadFiles": {
        "prefix": "mocha.lazyLoadFiles",
        "body": [ 
            "mocha.lazyLoadFiles(true)"
        ],
        "description": "Disables implicit call to Mocha#loadFiles in Mocha#run. This setting is used by watch mode, parallel mode, and for loading ESM files."
    },

    "mocha.loadFilesAsync": {
        "prefix": "mocha.loadFilesAsync",
        "body": [ 
            "mocha.loadFilesAsync()",
            "\t.then(() => mocha.run(failures => process.exitCode = failures ? 1 : 0))",
            "\t.catch(() => process.exitCode = 1);"
        ],
        "description": "The implementation relies on Node's require and import to execute the test interface functions and will be subject to its cache. Supports both CJS and ESM modules."
    },

    "mocha.noHighlighting": {
        "prefix": "mocha.noHighlighting()",
        "body": [ 
            "mocha.noHighlighting()"
        ],
        "description": "Disables syntax highlighting (in browser)."
    },

    "mocha.parallelMode": {
        "prefix": "mocha.parallelMode",
        "body": [ 
            "mocha.parallelMode(true)"
        ],
        "description": "Toggles parallel mode."
    },

    "mocha.reporter": {
        "prefix": "mocha.reporter",
        "body": [ 
            "mocha.reporter('xunit', { output: '/path/to/testspec.xunit.xml' })"
        ],
        "description": "Sets reporter to reporter, defaults to 'spec'."
    },

    "mocha.retries": {
        "prefix": "mocha.retries",
        "body": [ 
            "mocha.retries(1)"
        ],
        "description": "Sets the number of times to retry failed tests."
    },

    "mocha.rootHooks": {
        "prefix": "mocha.rootHooks",
        "body": [ 
            "mocha.rootHooks(hooks)"
        ],
        "description": "Assigns hooks to the root suite."
    },

    "mocha.run": {
        "prefix": "mocha.run",
        "body": [ 
            "mocha.run(failures => process.exitCode = failures ? 1 : 0)"
        ],
        "description": "To run tests multiple times (or to run tests in files that are already in the require cache), make sure to clear them from the cache first!"
    },

    "mocha.runGlobalSetup": {
        "prefix": "mocha.runGlobalSetup",
        "body": [ 
            "mocha.runGlobalSetup()"
        ],
        "description": "Run any global setup fixtures sequentially, if any. This is automatically called by Mocha#run unless the runGlobalSetup option is false. The context object this function resolves with should be consumed by Mocha#runGlobalTeardown."
    },

    "mocha.runGlobalTeardown": {
        "prefix": "mocha.runGlobalTeardown",
        "body": [ 
            "mocha.runGlobalTeardown()"
        ],
        "description": "Run any global teardown fixtures sequentially, if any. This is automatically called by Mocha#run unless the runGlobalTeardown option is false. Should be called with context object returned by Mocha#runGlobalSetup, if applicable."
    },

    "mocha.timeout": {
        "prefix": "mocha.timeout",
        "body": [ 
            "mocha.timeout(1000)"
        ],
        "description": "Sets timeout threshold value."
    },

    "mocha.ui": {
        "prefix": "mocha.ui",
        "body": [ 
            "mocha.ui('bdd')"
        ],
        "description": "Sets test UI name, defaults to 'bdd'."
    },

    "mocha.unloadFiles": {
        "prefix": "mocha.unloadFiles",
        "body": [ 
            "mocha.unloadFiles()"
        ],
        "description": "This allows required files to be 'freshly' reloaded, providing the ability to reuse a Mocha instance programmatically. Note: does not clear ESM module files from the cache."
    },

    "assert": {
        "prefix": "assert(expression, message)",
        "body": [
            "assert('foo' !== 'bar', 'foo is not bar')"
        ],
        "description": "Write your own test expressions."
    },

    "assert.fail": {
        "prefix": "assert.fail(actual, expected, [message], [operator])",
        "body": [
            "assert.fail(1, 2, 'custom error message', '>')"
        ],
        "description": "Throw a failure. Node.js assert module-compatible."
    },

    "assert.isOk": {
        "prefix": "assert.isOk(object, [message])",
        "body": [
            "assert.isOk('everything', 'everything is ok')"

        ],
        "description": "Asserts that object is truthy."
    },

    "assert.isNotOk": {
        "prefix": "assert.isNotOk(object, [message])",
        "body": [
            "assert.isNotOk('everything', 'this will fail')"
        ],
        "description": "Asserts that object is falsy."
    },

    "assert.equal": {
        "prefix": "assert.equal(actual, expected, [message])",
        "body": [
            "assert.equal(3, '3', '== coerces values to strings')"
        ],
        "description": "Asserts non-strict equality (==) of actual and expected."
    },

    "assert.notEqual": {
        "prefix": "assert.notEqual(actual, expected, [message])",
        "body": [
            "assert.notEqual(3, 4, 'these numbers are not equal')"
        ],
        "description": "Asserts non-strict inequality (!=) of actual and expected."
    },

    "assert.strictEqual": {
        "prefix": "assert.strictEqual(actual, expected, [message])",
        "body": [
            "assert.strictEqual(true, true, 'these booleans are strictly equal')"
        ],
        "description": "Asserts strict equality (===) of actual and expected."
    },

    "assert.notStrictEqual": {
        "prefix": "assert.notStrictEqual(actual, expected, [message])",
        "body": [
            "assert.notStrictEqual(3, '3', 'no coercion for strict equality')"
        ],
        "description": "Asserts strict inequality (!==) of actual and expected."
    },

    "assert.deepEqual": {
        "prefix": "assert.deepEqual(actual, expected, [message])",
        "body": [
            "assert.deepEqual({ tea: 'green' }, { tea: 'green' })"
        ],
        "description": "Asserts that actual is deeply equal to expected."
    },

    "assert.notDeepEqual": {
        "prefix": "assert.notDeepEqual(actual, expected, [message])",
        "body": [
            "assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' })"
        ],
        "description": "Assert that actual is not deeply equal to expected."
    },

    "assert.isAbove": {
        "prefix": "assert.isAbove(valueToCheck, valueToBeAbove, [message])",
        "body": [
            "assert.isAbove(5, 2, '5 is strictly greater than 2')"
        ],
        "description": "Asserts valueToCheck is strictly greater than (>) valueToBeAbove."
    },

    "assert.isAtLeast": {
        "prefix": "assert.isAtLeast(valueToCheck, valueToBeAtLeast, [message])",
        "body": [
            "assert.isAtLeast(5, 2, '5 is greater or equal to 2')"
        ],
        "description": "Asserts valueToCheck is greater than or equal to (>=) valueToBeAtLeast."
    },

    "assert.isBelow": {
        "prefix": "assert.isBelow(valueToCheck, valueToBeBelow, [message])",
        "body": [
            "assert.isBelow(3, 6, '3 is strictly less than 6')"
        ],
        "description": "Asserts valueToCheck is strictly less than (<) valueToBeBelow."
    },

    "assert.isAtMost": {
        "prefix": "assert.isAtMost(valueToCheck, valueToBeAtMost, [message])",
        "body": [
            "assert.isAtMost(3, 6, '3 is less than or equal to 6')"
        ],
        "description": "Asserts valueToCheck is less than or equal to (<=) valueToBeAtMost."
    },

    "assert.isTrue": {
        "prefix": "assert.isTrue(value, [message])",
        "body": [
            "assert.isTrue(true, 'it is true')"
        ],
        "description": "Asserts that value is true."
    },

    "assert.isFalse": {
        "prefix": "assert.isFalse(value, [message])",
        "body": [
            "assert.isTrue(true, 'it is false');"
        ],
        "description": "Asserts that value is false."
    },

    "assert.isNull": {
        "prefix": "assert.isNull(value, [message])",
        "body": [
            "assert.isNull(err, 'there was no error')"
        ],
        "description": "Asserts that value is null."
    },

    "assert.isNaN": {
        "prefix": "assert.isNaN",
        "body": [
            "assert.isNaN(NaN, 'NaN is NaN') "
        ],
        "description": "Asserts that value is NaN."
    },

    "assert.exists": {
        "prefix": "assert.exists",
        "body": [
            "assert.exists(foo, 'foo is neither `null` nor `undefined`')"
        ],
        "description": "Asserts that the target is neither null nor undefined."
    },

    "assert.isDefined": {
        "prefix": "assert.isDefined(value, [message])",
        "body": [
            "assert.isDefined(foo, 'foo has been defined')"
        ],
        "description": "Write your own test expressions."
    },

    "assert.isFunction": {
        "prefix": "assert.isFunction(value, [message])",
        "body": [
            "assert.isFunction(getFoo, 'we got foo')"
        ],
        "description": "Asserts that value is a function."
    },

    "assert.isObject": {
        "prefix": "assert.isObject(value, [message])",
        "body": [
            "assert.isObject(selection, 'selection is an object')"
        ],
        "description": "Asserts that value is an object of type ‘Object’ (as revealed by Object.prototype.toString). The assertion does not match subclassed objects."
    },

    "assert.isArray": {
        "prefix": "assert.isArray(value, [message])",
        "body": [
            "assert.isArray(menu, 'what kind of tea do we want?')"
        ],
        "description": "Asserts that value is an array."
    },

    "assert.isString": {
        "prefix": "assert.isString(value, [message])",
        "body": [
            "assert.isString('string', 'is string')"
        ],
        "description": "Asserts that value is a string."
    },

    "assert.isNumber": {
        "prefix": "assert.isNumber(value, [message])",
        "body": [
            "assert.isNumber(2, 'how many?')"
        ],
        "description": "Asserts that value is a number."
    },

    "assert.isFinite": {
        "prefix": "assert.isFinite(value, [message])",
        "body": [
            "assert.isFinite(cups, 'how many cups')"
        ],
        "description": "Asserts that value is a finite number. Unlike .isNumber, this will fail for NaN and Infinity."
    },

    "assert.isBoolean": {
        "prefix": "assert.isBoolean(value, [message])",
        "body": [
            "assert.isBoolean(true, 'it is a boolean')"
        ],
        "description": "Write your own test expressions."
    },

    "assert.instanceOf": {
        "prefix": "assert.instanceOf(object, constructor, [message])",
        "body": [
            "assert.instanceOf(foo, Bar, 'chai is an instance of bar')"
        ],
        "description": "Write your own test expressions."
    }


}